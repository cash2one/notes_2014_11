
* 前言
之前在百度的几个项目的存储选型中，曾经考虑到使用Redis，因为应用场景很适合。但是最
终因为对Redis的存储持久化，多机以及运维监控存在疑虑而放弃，并转用公司内部的KV存储。

* 资料搜集
+ [[http://www.cnblogs.com/liping13599168/archive/2011/04/12/2013094.html][Redis源码解析（1）——源码目录介绍]]
+ [[http://blog.nosqlfan.com/html/2949.html][Redis源码分析系列文章]]
+ [[http://blog.nosqlfan.com/html/4007.html][Redis运行流程源码解析]] （对Redis的网络通讯层分析得很详细）
  
** 第二批
+ [[https://github.com/springside/springside4/wiki/redis][Redis资料搜集（江南白衣）]]
+ [[http://origin.redisbook.com/en/latest/][Redis 设计与实现（第一版）]]
+ [[http://redis.readthedocs.org/en/latest/][Redis 命令参考]]

* Redis Client
通过Eclipse稍微阅读了Redis Client端的代码。Client端的代码位于redis-cli.c以及
hiredis.c中，其中后者是Client与Redis Server通讯的核心代码，前者封装了后者，提供给
用户以命令行的接口。

在redis-cli的交互式的每轮循环中，有会两个函数被先后调用。
#+begin_src C
int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
int redisGetReply(redisContext *c, void **reply);
#+end_src
* Redis Server
main函数位于redis.c的3091行。

#+begin_src c
/* Global vars */
struct redisServer server; /* server global state */
struct redisCommand *commandTable;
#+end_src

前者是Redes服务器的配置和状态的全局变量，其类型是个非常庞大的struct。server变量在
main函数刚开始就进行了初始化，相关函数是：

#+begin_src c
initServerConfig();
#+end_src

* redis.h
Redis的源码结构有个特点，就是 *在redis.h中声明所有重要的结构函数* 。这些函数包括
下面几类：
1. 工具函数。
2. 网络以及与客户端交互相关的函数。
3. Redis Object（如string/list/hash/set等）的构造和管理相关的函数。
4. Replication相关。
5. 持久化相关函数（AOF和RDB）。
6. Redis核心函数（如打日志，处理命令）。


* 数据结构
** redisClient
#+BEGIN_SRC cpp
/* With multiplexing we need to take per-client state.
 * Clients are taken in a liked list. */
typedef struct redisClient {
    int fd;
    redisDb *db;
    int dictid;
    robj *name;             /* As set by CLIENT SETNAME */
    sds querybuf;
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size */
    int argc;
    robj **argv;
    struct redisCommand *cmd, *lastcmd;
    int reqtype;
    int multibulklen;       /* number of multi bulk arguments left to read */
    long bulklen;           /* length of bulk argument in multi bulk request */
    list *reply;
    unsigned long reply_bytes; /* Tot bytes of objects in reply list */
    int sentlen;            /* Amount of bytes already sent in the current
                               buffer or object being sent. */
    time_t ctime;           /* Client creation time */
    time_t lastinteraction; /* time of the last interaction, used for timeout */
    time_t obuf_soft_limit_reached_time;
    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */
    int authenticated;      /* when requirepass is non-NULL */
    int replstate;          /* replication state if this is a slave */
    int repldbfd;           /* replication DB file descriptor */
    off_t repldboff;        /* replication DB file offset */
    off_t repldbsize;       /* replication DB file size */
    sds replpreamble;       /* replication DB preamble. */
    long long reploff;      /* replication offset if this is our master */
    long long repl_ack_off; /* replication ack offset, if this is a slave */
    long long repl_ack_time;/* replication ack time, if this is a slave */
    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */
    int slave_listening_port; /* As configured with: SLAVECONF listening-port */
    multiState mstate;      /* MULTI/EXEC state */
    int btype;              /* Type of blocking op if REDIS_BLOCKED. */
    blockingState bpop;     /* blocking state */
    long long woff;         /* Last write global replication offset. */
    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */
    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */
    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */

    /* Response buffer */
    int bufpos;
    char buf[REDIS_REPLY_CHUNK_BYTES];
} redisClient;
#+END_SRC

** redisDb
#+BEGIN_SRC cpp
/* Redis database representation. There are multiple databases identified
 * by integers from 0 (the default database) up to the max configured
 * database. The database number is the 'id' field in the structure. */
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
} redisDb;
#+END_SRC

* 学习回顾
** 初步了解，有些质疑 <2014-02-21 五>
初步了解了Redis的源码架构，并通过源码和别人的文章了解了Redis接受网络请求时的操作。
看到Redis在网络通讯层写了那么多底层代码，我在想显然这些东西通过RPC库可以简单地实
现。

*Redis目前给我的感觉是就一层套一层，而它真正属于自己的核心代码还是没有看到。*

看起来Redis作者是非常反感使用一些开源的库的，他要保证Redis代码的简洁。在我看来，
自己实现底层反倒让项目显得丑陋，因为它给自己增加了许多多余的代码，多余代码越多的
项目越丑陋。就像我上面说的，代码包裹了一层又一层，最里面才是Redis自己的核心代码。
