
* 前言
之前在百度的几个项目的存储选型中，曾经考虑到使用Redis，因为应用场景很适合。但是最
终因为对Redis的存储持久化，多机以及运维监控存在疑虑而放弃，并转用公司内部的KV存储。

* 资料搜集
+ [[http://www.cnblogs.com/liping13599168/archive/2011/04/12/2013094.html][Redis源码解析（1）——源码目录介绍]]
+ [[http://blog.nosqlfan.com/html/2949.html][Redis源码分析系列文章]]
+ [[http://blog.nosqlfan.com/html/4007.html][Redis运行流程源码解析]] （对Redis的网络通讯层分析得很详细）
  
** 第二批
+ [[https://github.com/springside/springside4/wiki/redis][Redis资料搜集（江南白衣）]]
+ [[http://origin.redisbook.com/en/latest/][Redis 设计与实现（第一版）]]
+ [[http://redis.readthedocs.org/en/latest/][Redis 命令参考]]

* Redis Client
通过Eclipse稍微阅读了Redis Client端的代码。Client端的代码位于redis-cli.c以及
hiredis.c中，其中后者是Client与Redis Server通讯的核心代码，前者封装了后者，提供给
用户以命令行的接口。

在redis-cli的交互式的每轮循环中，有会两个函数被先后调用。
#+begin_src C
int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
int redisGetReply(redisContext *c, void **reply);
#+end_src
* Redis Server
main函数位于redis.c的3091行。

#+begin_src c
/* Global vars */
struct redisServer server; /* server global state */
struct redisCommand *commandTable;
#+end_src

前者是Redes服务器的配置和状态的全局变量，其类型是个非常庞大的struct。server变量在
main函数刚开始就进行了初始化，相关函数是：

#+begin_src c
initServerConfig();
#+end_src

* redis.h
Redis的源码结构有个特点，就是 *在redis.h中声明所有重要的结构函数* 。这些函数包括
下面几类：
1. 工具函数。
2. 网络以及与客户端交互相关的函数。
3. Redis Object（如string/list/hash/set等）的构造和管理相关的函数。
4. Replication相关。
5. 持久化相关函数（AOF和RDB）。
6. Redis核心函数（如打日志，处理命令）。


* 数据结构
** redisClient
#+BEGIN_SRC cpp
/* With multiplexing we need to take per-client state.
 * Clients are taken in a liked list. */
typedef struct redisClient {
    int fd;
    redisDb *db;
    int dictid;
    robj *name;             /* As set by CLIENT SETNAME */
    sds querybuf;
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size */
    int argc;
    robj **argv;
    struct redisCommand *cmd, *lastcmd;
    int reqtype;
    int multibulklen;       /* number of multi bulk arguments left to read */
    long bulklen;           /* length of bulk argument in multi bulk request */
    list *reply;
    unsigned long reply_bytes; /* Tot bytes of objects in reply list */
    int sentlen;            /* Amount of bytes already sent in the current
                               buffer or object being sent. */
    time_t ctime;           /* Client creation time */
    time_t lastinteraction; /* time of the last interaction, used for timeout */
    time_t obuf_soft_limit_reached_time;
    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */
    int authenticated;      /* when requirepass is non-NULL */
    int replstate;          /* replication state if this is a slave */
    int repldbfd;           /* replication DB file descriptor */
    off_t repldboff;        /* replication DB file offset */
    off_t repldbsize;       /* replication DB file size */
    sds replpreamble;       /* replication DB preamble. */
    long long reploff;      /* replication offset if this is our master */
    long long repl_ack_off; /* replication ack offset, if this is a slave */
    long long repl_ack_time;/* replication ack time, if this is a slave */
    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */
    int slave_listening_port; /* As configured with: SLAVECONF listening-port */
    multiState mstate;      /* MULTI/EXEC state */
    int btype;              /* Type of blocking op if REDIS_BLOCKED. */
    blockingState bpop;     /* blocking state */
    long long woff;         /* Last write global replication offset. */
    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */
    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */
    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */

    /* Response buffer */
    int bufpos;
    char buf[REDIS_REPLY_CHUNK_BYTES];
} redisClient;
#+END_SRC

** redisDb
#+BEGIN_SRC cpp
/* Redis database representation. There are multiple databases identified
 * by integers from 0 (the default database) up to the max configured
 * database. The database number is the 'id' field in the structure. */
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
} redisDb;
#+END_SRC

* Redis实践
** 当要get的key数目非常多时（MGET与pipeline）
虽然get每个key的时间非常短，但是如果遇到那种需要get非常多的key的场景时，
这些get操作的累加耗时就非常非常的长了。耗时主要好在网络连接上，所以需
要研究下Redis是否提供的批量get的方式。

+ [[http://stackoverflow.com/questions/3329408/is-there-mget-analog-for-redis-hashes][Is there MGET analog for Redis hashes?]]
+ [[http://stackoverflow.com/questions/4929202/most-efficient-way-to-get-several-hashes-in-redis][Most efficient way to get several hashes in Redis?]]
通过上面的文章，我了解到Redis为string类型提供了MGET的批量get key的接口，
这是符合我的需求的。但是为hash类型提供了HMGET的接口的语义却是 *一次get
一个key的多个字段*，而不是 *一次get多个key的多个字段* ，这个接口不符合
我的要求。

还好Redis提供了强大的pipeline功能，能够批量执行任意操作。但是有一个副
作用，那就是 *pipeine会独占redis client* ，故用pipeline时还是要慎重一
点的。

** 使用hiredis的pipeline，部分key无法正常写入redis
查看官方的test文件，发现它的用法是： *redisAppendCommand* 和
*redisGetReply* 一一对应。我也修改我的代码，发现这样就可以正常写入了！

至于为啥，我现在还不大了解，我决定先放着，以后可以问别人。不过我通过阅
读下面两文：
+ [[https://github.com/redis/hiredis][README.md(HIREDIS)]]
+ [[http://informatikr.com/2012/redis-pipelining.html][Automatic Optimal Pipelining of Redis Commands]]

得知redisGetReply可能使hiredis阻塞。即调用redisGetReply时：
#+BEGIN_EXAMPLE
1. The input buffer is non-empty:
  + Try to parse a single reply from the input buffer and return it
  + If no reply could be parsed, continue at 2
2. The input buffer is empty:
  + Write the entire output buffer to the socket
  + Read from the socket until a single reply could be parsed
#+END_EXAMPLE


* 学习回顾
** 初步了解，有些质疑 <2014-02-21 五>
初步了解了Redis的源码架构，并通过源码和别人的文章了解了Redis接受网络请求时的操作。
看到Redis在网络通讯层写了那么多底层代码，我在想显然这些东西通过RPC库可以简单地实
现。

*Redis目前给我的感觉是就一层套一层，而它真正属于自己的核心代码还是没有看到。*

看起来Redis作者是非常反感使用一些开源的库的，他要保证Redis代码的简洁。在我看来，
自己实现底层反倒让项目显得丑陋，因为它给自己增加了许多多余的代码，多余代码越多的
项目越丑陋。就像我上面说的，代码包裹了一层又一层，最里面才是Redis自己的核心代码。
