#+TITLE: Python

* 前言
在浏览 Google 的一些网页之后，突然再次涌起了学习 Python 的热情。于是我无限期停止了学
习 Ruby 的进程，开始系统习学习 Python。

我第一次接触 Python 是在 2011 年，那时我在阅读《集体智慧编程》，并照着书敲完了上面是
所有 Python 代码。之后在工作中也经常会用到 Python 写脚本，每次用的时候，基础语法还好，
但是一旦用到函数库，我就不得不通过搜索，非常的没效率。我一直想找个机会来进行几轮
系统的学习。

* 资料搜集
** 文档
+ [[http://docs.python.org/2/][Python 2.7 文档]]
+ [[http://docs.python.org/2/library/index.html][Python 标准库]]

** 书籍
+ [[http://woodpecker.org.cn/diveintopython/][深入 Python :Dive Into Python 中文版（啄木鸟社区）]]
+ [[http://book.douban.com/subject/3117898/][Python 源码剖析]]

* re 模块
** group
+ [[https://docs.python.org/2/library/re.html][re — Regular expression operations]]

下面面的代码利用 re 模块实现了正则查找和捕获，将一行日志中的 pid 字段给捕获
并打印。
#+BEGIN_SRC python
#!/bin/env python

import re
import sys 

for line in sys.stdin:
    m = re.search(r"pid=(\d+)&", line)
    if m != None:
        pid = m.group(1).strip("\n")
        print pid 
#+END_SRC

* pycurl
** curl 与 ftp
通过 curl 配合 ftp，能实现不登陆机器就能方便地实现一些文件系统操作。如下面几行代码
实现了远程 ls 一个指定目录的功能：
#+BEGIN_SRC python
# ftp_dir 变量的格式例如：ftp://ftp.cn.freebsd.org/pub/FreeBSD/
def ListDirectory(ftp_dir):
    buf = cStringIO.StringIO()
    c = pycurl.Curl()

    c.setopt(c.URL, ftp_dir)
    c.setopt(c.WRITEFUNCTION, buf.write)
    c.setopt(pycurl.TIMEOUT, 1)
    c.perform()

    file_list = buf.getvalue()
    buf.close()
    return file_list
#+END_SRC
** 超时设置
curl 是一种网络交互过程，这种过程必须要考虑超时设置。
设置方法如下：
#+BEGIN_SRC python
# 设置超时为 1 秒
c.setopt(pycurl.TIMEOUT, 1)
#+END_SRC
* datetime
** timedelta
两个 datetime 相减就能得到一个 timedelta，所以要想得到两个 datetime 相差的秒数，可以
拿它们相减，并对得到的 timedelta 调用 seconds 方法。下面例子演示了对数据库表中的
DateTime 类型字段取它们相差的秒数：
#+BEGIN_SRC python
data_slices = engine.execute('SELECT base_time, end_time, ready_time, data_size FROM data_slice '
                                     'WHERE log_module_id = ' + str(log_module_id) +
                                     ' AND DATE(base_time) = "' + base_date + '"')

for data_slice in data_slices:
    slice_delay_time = (data_slice.ready_time - data_slice.end_time).seconds
#+END_SRC
** string -> datetime -> timestamp
#+BEGIN_SRC python
datetime_start = "2014-07-29 18:00:00"
datetime_end = "2014-07-29 19:00:00"
timestamp_start = int(time.mktime(datetime.datetime.strptime(datetime_start, '%Y-%m-%d %H:%M:%S').timetuple()))
timestamp_end = int(time.mktime(datetime.datetime.strptime(datetime_end, '%Y-%m-%d %H:%M:%S').timetuple()))
#+END_SRC

感想：很坑爹，很丑陋，调用了 N 多时间相关的函数。

* 调用子进程
Python 里有 N 种方法调用子进程，我自己就用过 os.system 和 os.popen3，此外还有
subprocess 和 commands。

我有个需求，就是在 Python 中调用公司一个命令行工具来获取某个 Naming Service 的全部实例的
信息。我关注的是调用的返回状态码（用以判断调用成功与否），和标准输出信息（进一步
解析，返回给前端），我注意到了 commands，发现它完美契合我的需求，并且据 [[http://blog.csdn.net/menglei8625/article/details/7494094][此文]] 的说
法说还有 *不阻塞* 的特性（但经过我的测试，发现 *不阻塞* 纯属妄想）

顺带说一句，公司环境下有这个命令行，但是我在我的 Mac 下开发，没有这个命令行，于是
我机智地 Mock 了一把。如下：
#+BEGIN_SRC sh
sudo vi /bin/get_instance_by_service

echo "tc-mo-ucenter00.tc 10.26.185.29 mimo-ucenter-wiaui.MO.all 0 0                                    
tc-mo-wap03.tc 10.26.198.51 wap.MO.tc 404 0                                                            
tc-mo-wap04.tc 10.26.198.71 wap.MO.tc 404 0"
#+END_SRC

* 问题记录
** Mac 下 pip 安装一些模块失败，报"clang: error"
我在 Mac 安装 PIL，但是总是失败。错误信息如下：
#+BEGIN_SRC sh
sudo pip install Pillow 
Downloading/unpacking Pillow
  Downloading Pillow-2.4.0.zip (6.5MB): 6.5MB downloaded
  Running setup.py egg_info for package Pillow
...
...
clang: error: unknown argument: '-mno-fused-madd' [-Wunused-command-line-argument-hard-error-in-future]

clang: note: this will be a hard error (cannot be downgraded to a warning) in the future

error: command 'cc' failed with exit status 1

----------------------------------------
Cleaning up...
...
#+END_SRC

用网上找到了 N 多方法尝试都无法解决此问题，最后，终于找到了这篇文章：
+ [[http://bruteforce.gr/bypassing-clang-error-unknown-argument.html][Bypassing “clang: error: unknown argument”]]

并按照这篇文章提供的解法来安装，终于成功。
#+BEGIN_SRC sh
sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future  pip install pillow
#+END_SRC

该问题的原因是： *Mac 的 LLVM compiler 升级新版后，将识别不了的命令行参数
当成错误* 。这个改动导致了很多通过 pip 安装的 Python 模块和通过 gem 安装的
Ruby 包发生了安装失败的问题。

这里我不得不吐槽一下 Mac，在非 Xcode 开发的环境兼容性的处理上 *不够严肃*
（相对一些 Linux 发行版）。

** bad interpreter: Permission denied
我在公司的机器上安装 percol，装好一运行，出现如下结果：
#+BEGIN_SRC sh
[work@cq01-testing-ecom327.cq01.baidu.com master]$ percol
-bash: /home/work/.jumbo/bin/percol: /home/users/zhongyi01/.jumbo/bin/python: bad interpreter: Permission denied
#+END_SRC

怀疑是 Python 解释器环境配置问题，于是打开*/home/work/.jumbo/bin/percol*
，发现该 Python 脚本的第一行写着：
#+BEGIN_SRC python
#!/home/users/zhongyi01/.jumbo/bin/python
#+END_SRC

我将它改成如下行后，问题解决！
#+BEGIN_SRC python
#!/bin/env python
#+END_SRC

** ascii codec can t decode byte 0xef in position 0 ordinal not in range 128
解法：
#+BEGIN_SRC python
import sys 
reload(sys) 
sys.setdefaultencoding('utf8') 
#+END_SRC
+ [[http://www.cnblogs.com/DjangoBlog/p/3543430.html]]
* 学习回顾 
** 或许我需要的只是背诵一下 api，以及一个能自动提示的 IDE <2014-02-23 日>
翻几本 Python 书，发现都眼熟的很，可看的不多。


