#+TITLE: C++模板
#+DATE: 2014-04-21

* 为啥模板必须实现在头文件中？
编译器在 *实例化* 一个模板时，会根据模板参数来创建一个新类。编译器需要
能访问到模板的各个方法的实现，否则无法实例化一个模板。假如我们将模板的
实现放到了cpp文件中，编译器在编译使用该模板的cpp文件时，该模板的实现对
于编译器是看不见的，这样 *编译器是无法将该模板实例化的* 。

参考： [[http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file][Why can templates only be implemented in the header file?]]

* 实践
** RPC请求的转发
最近写的一个Server要多实例部署，每个实例管理系统的一部分Client。我希望
这些Server能够提供以HTTP的方式提供完全相同的服务，例如，用户通过HTTP来
向任何一个Server查询某个Client的状态，这个Server先判断这个Client是否是
自己管理，如果不是，则它要把请求转发给该Client所属的Server。

这个系统的各个模块都是通过Protobuf RPC来做交互，系统对外也是通过
HTTP包裹着Protobuf RPC来提供接口。所以，下面将Server提供的服务也称作
RPC服务。

对于单个RPC服务，Server很容易实现请求的转发，代码量也不大。但是，该Server
提供很多RPC服务，如果针对每个服务都写一篇转发，会带来很多重复的代码。
我想通过C++的模板来去掉这部分重复。

C++模板这项的技术的主要目的就是去重复，所以我们分析一下每个RPC请求的转发
过程以及相关的数据结构的相似点和不同点，看看该如何套用模板。

1. RPC的Request和Response其实都是Message。在RPC转发的过程中，是不需要
   考虑该数据的本身的。

...
...

最后，我败了，因为我发现每个RPC请求都会调用不同的函数，模板能够解决掉参数
类型不同带来的重复，但是对于函数调用的不同，模板看起来很无能为力。由于该函
数调用其实是调用本地对象的函数，无法在调用模板类的的RPC转发函数时讲函
数指针地址传进去。

最后，我决定不用模板，用C++的指针类型强转来实现去重复。具体实现如下：

实现一个类，该类主要提供一个 *DeliverRequest* 的接口，该函数有一个参数
叫
** TODO 重构完这个类后继续写。 






