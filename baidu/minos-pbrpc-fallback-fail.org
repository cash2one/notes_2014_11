#+TITLE: 

* 加大pbrpc的server工作线程数目
从8改为20，发现没有改善。

* 加大pbrpc的serve的单连接发送队列的缓存大小
从2M改为20M，仍然没有改善，于是改小为10M。

* 拆分SyncWithNamingService函数的大锁为3个小锁
是在SyncWithNameService中调用Fallback的，这里用的是写锁，而RegisterNode用的也是写
锁，怀疑发生了竞争冲突。

改完重新上线后，发现仍然没有改善。

* 拆分UpdateAllLogFlows()等各个函数处的读写锁
* 尝试为LogFlowManager中的Map的每个元素配置一个锁
看起来很好，GetLogFlow将各不影响，但关键问题是，这些锁是用map管理起来的，而这个
map本身就会有读写加锁的问题。

* 总结和教训
本次问题的原因可以归结为： *锁粒度太大导致网络交互因为超时而失败* 。

给我的教训是：
1. 使用读写锁时，多想一想锁住的临界区的规模。特别地，思考它会不会随着系统规模的增
   大而增大。
2. 网络交互失败以及网络交互缓慢可能与加锁有关。




