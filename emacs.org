* Emacs的几个编辑循环
在了解Emacs的基本快捷键之后，我对于Emacs还是疑惑重重，这时候，就需要通过Emacs的基
本使用场景来学习Emacs。

打开文件 -> 修改文件 -> 保存文件

打开文件 -> 打开buffer -> 关闭buffer（buffer/window分为两种，一种可以用q来关闭，
一种只能用 C-x K或C-x 0）

执行操作 -> 撤销操作

执行操作 -> 中止操作

* Emacs的排查/调试（当使用emacs遇到问题时）
我们执行一个命令，但是Emacs并没有按照我们预期的方式来执行，而且也没有告诉我们哪里
出问题了，这时候，我们就得要进行排查/调试了。

我们执行的每一个命令，在Emacs内部其实都是对应这一个emacs lisp函数。这些函数的运行
日志是输出在一个名为 *message* 的buffer中，我们打开这个名为 *message* 的buffer就
可以查看emacs lisp函数的运行日志，然后就能对Emacs就进行更进一步的排查了。

打开 *message* 这个buffer的操作的方式是： M-x switch-to-buffer 回车，然后在下图的
buffer列表中选择 *message* 。

[[./img/emacs-1.png]]

补充一下，当用Emacs打开一个文件时，Emacs默认会打开 *1* 个窗口（window）和 *3* 个
   缓冲区（buffer）。三个buffer分别为：
1. 当前文件的buffer
2. Emacs lisp的运行日志buffer。名为 *message*
3. 临时buffer，相当于草稿。名为 *scratch* 

** 进阶：打印出backtrace
Emacs的message buffer中只有粗略的信息，有时候无法精确地定位问题。这时候，就该拿出
杀手锏 *debug-on-error* 了。执行：
#+begin_src emacs-lisp
M-x toggle-debug-on-error
#+end_src

打开 *debug-on-error* ，然后执行一个命令（emacs lisp）函数，再按 *C-g* 就能打印出
函数调用栈（[[http://stackoverflow.com/questions/14067524/how-to-show-backtrace-for-emacs][参考此文]]）。

* Emacs的备份功能（自动产生的*~文件）
当我们执行保存（如C-x C-s），Emacs在保存时发现目录下有同名文件，这时它会使用 *原
文件名后面缀上~* 作为为新名字来保存到原目录，这就是Emacs的备份功能。Emacs的这个功
能会导致目录下文件凌乱，我们需要稍稍地配置一下，让我们能更好地享受Emacs的备份功能。

#+begin_src emacs-lisp
;;; Backup                                                                                             
(setq                                                                                                  
  backup-by-copying t ; 自动备份                                                                       
  backup-directory-alist                                                                               
  '(("." . "~/.backup")) ; 自动备份在目录"~/.backup"下                                                 
  delete-old-versions t ; 自动删除旧的备份文件                                                         
  kept-new-versions 6 ; 保留最近的6个备份文件                                                          
  kept-old-versions 2 ; 保留最早的2个备份文件                                                          
  version-control t) ; 多次备份        
#+end_src

[[http://www.cnblogs.com/samael/articles/2033644.html][参考文章]]

* Emacs/Vim的吐槽文
+ [[http://www.cr173.com/html/11113_1.html][Emacs作为IDE编程环境的不足]]

* 我的.emacs和.emacs.d为啥不起效？
按照 [[http://www.emacswiki.org/emacs/DotEmacsDotD][Emacs Wiki的说法]] ，当存在.emacs时，则优先加载.emacs，而不加
载.emacs.d/init.el。

我下载了 [[https://github.com/bbatsov/prelude][Emacs Prelude]] ，并我按照要求，放好.emacs.d/，删除.emacs，并满怀希望地打
开emacs，发现木有生效！我在网上搜寻解决之道，还通过在在.emacs.d/init.el尾部加上打
印到message buffer的语句来进行debug。
#+BEGIN_SRC emacs-lisp
(message "init.el ends here") 
#+END_SRC

然后我发现，我的emacs根本没有加载.emacs.d/init.el，也没有加载.emacs。这时候，我怀
疑是我的环境搞的鬼。我用的是Mac OS X，并且从一个用户su到另外一个用户来使用emacs，
或许某些环境变量用的还是原先用户的环境变量。于是我在shell中执行：
#+BEGIN_SRC sh
env | grep elvestar # elvestar是原先的用户名
#+END_SRC

返回结果中有三个环境变量用的还是原先的用户名elvestar，应该就是这些环境变量搞的鬼！
#+BEGIN_SRC sh
LOGNAME=elvestar
PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/go/bin:/usr/texbin:/Users/elvestar/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
OLDPWD=/Users/elvestar
#+END_SRC

我依次修改这些环境变量为新用户下的对应值，发现只需要修改 *LOGNAME* ，我
的.emacs.d/就生效了。
#+BEGIN_SRC sh
export LOGNAME=zhongyi
#+END_SRC

问题终于解决了，我因此收获了几条教训：
1. 用su来切换用户，环境变量改变不彻底。
2. emacs根据 *LOGNAME* 来决定加载哪个.emacs.d/。

* Mode Hooks
我们不希望安装的每一个插件在每一种模式下都被加载，因为这样会带来不必要
的开销，让我们的Emacs越来越慢。我们希望Emacs提供 *让插件在指定模式下加
载，而在其他模式下不加载* 的功能。

很显然，Emacs提供了这样的功能。语法如下：
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'linum-mode)
#+END_SRC
上面的语句实现了再C++模式下开启行号显示。

参考：
+ [[http://www.emacswiki.org/emacs/ModeHooks][ModeHooks (Emacs Wiki)]]

* 学习回顾
** 成为Emacs用户 <2014-02-20 四>
我从13年12月31日开始学习Emacs，断断续续学到现在，已经是Emacs入门了。我已经掌握
了：
1. 基本编辑
2. 修改~/.emacs配置
3. 安装Emacs插件
4. 调试Emacs，排查问题
5. Org-mode

我已经成功地吧我除了代码之外的所有笔记和文档的编辑从Vim/Sublime Text/Evernote上全
部切换到Emacs上来了，并且感受到了 *工具升级带来的巨大便利* 。

对于Emacs附带的编辑器，我觉得它相对Vim来说非常的原始，只提供有限的移动和编辑指令。
但即便如此，也比Evernote等工具附带的编辑器要方便很多。下一步我会尝试viper/evil插
件，让Vim之魂附身于Emacs，同时也是解放我的 *氪金左小指* 。



